---
title: "Clustering i ACP"
author: "Alba Linares y Maria Àngels"
format: html
editor: visual
---

## Presentació de les Dades:

En primer lloc, el repositori on trobem tota la informació d'aquest projecte és <https://github.com/mariangelsllobera/Inferencia-Multivariante.git>

Ara, carreguem el nostre DS, basat en observacions de diamants:

```{r, echo=FALSE}
library(ggplot2)
library(tibble)
library(dplyr)
glimpse(diamonds)
```

La **pregunta** què volem respondre amb aquest conjunt de dades és quin

## Anàlisi exploratòria de les dades:

Facem un petit resum i anàlisi exploratòria de les nostres dades. Notem que ja estan en format tidy: tenim 53940 observacions de 10 variables.

Recordem que les variables del nostre dataset són

-   *carat*: El pes del diamant en quirats. Un quilate és una unitat de mesura de pes utilitzada en gemologia i joieria per mesurar diamants i altres pedres precioses. Un quilate equival a 0.2 grams o 200 mil·ligrams. És important tenir en compte que el pes d'un diamant no és l'únic factor que determina el seu valor; altres factors com la claredat, el color i el tall també són fonamentals.

-   *cut*: La qualitat del tall del diamant, que pot tenir els nivells següents: "Fair", "Good", "Very Good", "Premium" i "Ideal".

-   *color*: El color del diamant, que es codifica en lletres de la "J" (pitjor) a la "D" (millor).

-   *clarity*: La claredat del diamant, que pot tenir els nivells següents: "I1" (la pitjor) fins a "IF" (la millor).

-   *depth*: La profunditat total del diamant com a percentatge del seu diàmetre.

-   *table*: L'amplada de la part superior del diamant expressat com un percentatge del diàmetre total.

-   *price*: El preu del diamant en dòlars nord-americans.

-   *x*: La longitud en mil·límetres.

-   *y*: L'amplada en mil·límetres.

-   *z*: La profunditat en mil·límetres.

Aquestes variables s'utilitzen habitualment en anàlisi de diamants i poden ser útils per a l'avaluació de qualitat i preus de diamants en funció de les seves característiques.

Vegem com són aquestes variables:

```{r, echo = FALSE}
summary(diamonds)
dim(diamonds)
```

Com tenim moltes observacions considerarem un subconjunt del dataset de forma aleatòria.

```{r}
diamants <- diamonds[sample(nrow(diamonds), 700, replace = FALSE),] #seleccionarem 700 mostres aleatòries atès que el df original té massa observacions per a després poder realitzar els clusterings
#dim(diamants)
```

Llavors, tenim 7 variables quantitatives: carat, depth, table, price, x, y, z. A més, trobem una variable qualitativa: color, amb 7 possibles nivells; i una d'ordinal: cut.

```{r}
diamants %>% 
  ggplot(aes(x = cut)) +
  geom_bar(fill="blue") + 
  labs(x="Qualitat del tall del diamant", y="Nombre de diamants") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold")) 
```

La majoria de diamants del nostre DS són de qualitat alta.

```{r}
diamants %>% 
  ggplot(aes(x = color)) + 
  geom_bar(fill='pink') +
  labs(x="Color del diamant", y="Nombre de diamants") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"))
```

Respecte al color, vegem que hi ha més diversitat, però el color J és el que manco unitats té.

Vegem la distribució de les dades en funcio del color i de cut mitjançant un diagrama de mosaic.

```{r,echo=FALSE}

library(vcd)

a<- diamants %>%

select(color,cut) %>%

na.omit()

a2<- table(a)

mosaicplot(a2,shade=TRUE, main="")

```

Estudiem la distribució dels diamants en funció del preu:

```{r}
ggplot(data=diamonds) + 
  geom_histogram(binwidth=500, aes(x=price)) + 
  ggtitle("Distribució dels preus dels diamants") + 
  xlab("Preu dels diamants") + 
  ylab("Freqüència") + 
  theme_minimal()
```

Aquesta és una distribució de cua llarga, amb una concentració elevada d'observacions per sota dels 5.000.

```{r}
ggplot(diamonds, aes(x = carat, y = price, color = color)) +
  geom_point() +
  labs(title = "Scatterplot of Diamond Carat vs Price",
       x = "Carat",
       y = "Price")
```

Sembla que, indistintivament del color del diamant, el preu tendeix a augmentar quan carat creix.

```{r}
ggplot(diamonds, aes(x = carat, fill = color)) +
  geom_histogram(binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = "Histogram of Diamond Carat vs Frequency",
       x = "Carat",
       y = "Frequency") 
```

La distribució és semblant a la dels preus (de cua llarga).

```{r}
mean_values <- diamonds %>%
  group_by(cut) %>%
  summarize(mean_carat = mean(carat))

ggplot(diamonds, aes(x = cut, y = carat, fill = cut)) +
  geom_violin(alpha = 0.7) +
  geom_point(data = mean_values, aes(x = cut, y = mean_carat),
             color = "black", size = 3, shape = 19) +  
  labs(title = "Violin Plot of Diamond Cut vs Carat",
       x = "Diamond Cut",
       y = "Carat") +
  scale_fill_manual(values = c("#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e")) +  # Custom color palette
  theme_minimal()
```

Les mitjanes de les carat són molt semblants, si les comparam entre qualitats del tall. Ara bé, les distribucions són prou diferents.

Vegem quina correlació hi ha entre les variables quantitatives

```{r,echo=FALSE}
library(ggcorrplot)

diamants %>%

na.omit(.) %>%

select(carat, depth, price) %>%

cor(.) %>%

ggcorrplot(., hc.order = TRUE, type = "lower", colors = c("#6D9EC1","yellow", "#E46726"))

```

Notem que la variable carat (el pes del diamant amb quilats) està molt correlacionada amb les dimensions d'aquest (x,y i z), la qual cosa té sentit. També estan molt correlacionades positivament les variables x,y,z, carat i preu.

També vegem que les variables depth i table tenen una mica de correlació negativa.

## Anàlisi de Clustering

El nostre objectiu es predir el rang de preu que tenen els diamants mitjançant l'informació que ens proporcionen les altres variables.

### Preparació de les dades per al posterior procés de clustering
Primer, cream una nova variable "price_grups" que emagatzema els preus dels diamants per rangs.

```{r}
diamants$price_grup <- cut(diamants$price, breaks = c(0,1000,2500, 5000, 10000, 15000, 20000, Inf),
                             labels = c("0-1000", "1000-2500","25001-5000", "5001-10000", "10001-15000", "15001-20000", "20001+"))

# Visualizem la distribució dels diamants en cada rang de preus
ggplot(diamants, aes(x = price_grup, fill = price_grup)) +
  geom_bar() +
  labs(title = "Distribució dels diamants en diferents rangs de preus",
       x = "Rang de preus",
       y = "nombre de diamants")
```

```{r}
table(diamants$price_grup) 
```

Com hem vist abans al summary els valors de la variable "carat" varien entre 0.23 i 2.3 i té mitjana 0.8161 i la variable "depth" varia entre 57.80 i 67.20 i té mitjana 61.84.

Aleshores, com la magnitud entre variables difereix de forma notable entre variables és convenient escalarles abans de fer el clustering.

```{r}
#primer seleccionam nomes les variables que ens interessen pel clustering
dades <- diamants %>% 
  na.omit(.) %>%
  select(carat)
dades <- scale(dades, center = TRUE, scale = TRUE)
```


Una forma senzilla d'estimar el nombre K òptim de clústers quan no es disposa d'informació addicional en la qual basar-se és aplicar l'algorisme per a un rang de valors de K, identificant aquell a partir del qual la reducció en la suma total de variància intraclúster deixa de ser substancial.

Usarem la funció fviz_nbclust() que automatitza aquest procés. En aquest cas, donat que es sospita de la presència d'outliers, s'emplea la distància de Manhattan com a mesura de similitud.

Vegem-ho

```{r}
library(cluster) 
library(factoextra) 

fviz_nbclust(x = dades, FUNcluster = pam, method = "wss", 
diss <- dist(dades, method = "manhattan")) 
```

Notem que a partir del cluster 4 la reducció en la suma total de cuadrats interns s'estabilitza. Per tant, agafam k=4.

### Clúster usant l'algorisme PAM

```{r}
set.seed(1234) 
pam_clusters <- pam(x = dades, k = 4, metric = "manhattan") 
pam_clusters 
```

```{r}
#ARREGLAR QUE ES GRAFICS NO ES VEUEN
hc_completo <- hclust(d = diss, method = "complete") 
hc_average  <- hclust(d = diss, method = "average") 
hc_single   <- hclust(d = diss, method = "single") 

#par(mfrow = c(3, 1)) 
#plot(hc_completo, labels = diamants$price_grup, ylab = "", xlab = "", sub = "",
#main = "Linkage completo", cex = 0.8) 
#plot(hc_average, labels = diamants$price_grup, ylab = "", xlab = "", sub = "", 
#main = "Linkage average", cex = 0.8) 
#plot(hc_single, labels = diamants$price_grup, ylab = "", xlab = "", sub = "", 
#main = "Linkage single", cex = 0.8)

fviz_dend(x = hc_completo, k = 4, cex = 0.6,
              main="Linkage complet") +
 geom_hline(yintercept = 5.5, linetype = "dashed")
fviz_dend(x = hc_average, k = 4, cex = 0.6,
              main="Linkage mitjà") +
 geom_hline(yintercept = 5.5, linetype = "dashed")
fviz_dend(x = hc_single, k = 4, cex = 0.6, 
  main="Linkage single") +
 geom_hline(yintercept = 5.5, linetype = "dashed")
```

```{r}
clusters <- cutree(tree = hc_completo, k = 4) 
table(clusters, diamants$price_grup, dnn = list("clusters", "preu")) 
```

Tots els diamants amb preus al rang 0-1000 cauen en el clúster 1. Els que es troben en els rang 2501-5000 cauen en el cluster 2 manco un petita quantitat (4 diamants de 71).

```{r}
#fviz_cluster(object = list(data = dades, cluster = cutree(hc_completo, k = 4)),
 #ellipse.type = "convex",
 #repel = TRUE,
 #show.clust.cent = FALSE) +
#theme_bw()
```


# PROVES MALL
## Opció 1: clúster particional usant l'algorisme de Lloyd

```{r}
library(factoextra)
diamants_subset =  diamonds[sample(nrow(diamonds), 500, replace = FALSE),] %>% 
  mutate(cut = as.integer(cut), clarity = as.integer(clarity)) %>% 
  select(-color,-x,-y,-z)%>% 
   na.omit() 

diamants_subset  %>% 
   scale()

fviz_nbclust(diamants_subset, kmeans, method = "wss")
```
Pel mètode del colze, concloem que el nombre òptim de clusters és k=2.

```{r}
set.seed(454)
diamants_cluster <- kmeans(diamants_subset, centers = 2, algorithm = "Lloyd")
diamants_subset$cluster <- diamants_cluster$cluster
fviz_cluster(diamants_cluster, data = diamants_subset)
```

```{r}
diamants_subset %>% 
  group_by(cluster) %>% 
  summarise_all(mean)
```
Vegem que la diferència principal dels clusters rau a carat i en el preu.

## Opció 2: clúster jeràrquic aglomeratiu 

Vegem què passa si no especifiquem el nombre de clusters a priori
```{r}
diamants_subset <- diamonds[sample(nrow(diamonds), 500, replace = FALSE),] %>% 
  mutate(color = as.integer(color), cut = as.integer(cut), clarity = as.integer(clarity))
```

```{r}
diamants_subset %>% mutate(price_group = cut(diamants_subset$price, breaks = c(0,1000,2500, 5000, 10000, 15000, 20000, Inf),labels = c("0-1000", "1000-2500","25001-5000", "5001-10000", "10001-15000", "15001-20000", "20001+")))
```


```{r}
dades <- diamants_subset %>% 
  select(carat) #volem veure si pot predir el preu d'un diamant en base al cluster
matriz_distancias <- dist(x = dades, method = "manhattan")

hc_completo <- hclust(d = matriz_distancias, method = "complete")
hc_average <- hclust(d = matriz_distancias, method = "average")
hc_single <- hclust(d = matriz_distancias, method = "single")
par(mfrow = c(3, 1))

plot(hc_completo, labels = diamants_subset$price_group, ylab = "", xlab = "", sub = "",
 main = "Linkage completo", cex = 0.8)
plot(hc_average, labels = diamants_subset$price_group, ylab = "", xlab = "", sub = "",
 main = "Linkage average", cex = 0.8)
plot(hc_single, labels = diamants_subset$price_group, ylab = "", xlab = "", sub = "",
 main = "Linkage single", cex = 0.8)

```

